import os
import streamlit as st
import pandas as pd
import sqlite3
from pathlib import Path
import datetime
from datetime import timezone
import logging
import ccxt
from symbols import SYMBOLS  # Lista dei simboli disponibili
from binance.client import Client
from binance.exceptions import BinanceAPIException
from src.core_and_scheduler import auto_execute_pending, fetch_last_closed_candle
import yaml
import streamlit as st
import streamlit_authenticator as stauth
from src.binance_utils import has_sufficient_balance
from symbols import SYMBOLS

# Imposta la configurazione della pagina Streamlit
st.set_page_config(page_title='Binance Scheduler', layout='wide')

# Carica config credenziali
with open("credentials.yaml") as file:
    config = yaml.safe_load(file)

auth = stauth.Authenticate(
    config["credentials"],
    config["cookie"]["name"],
    config["cookie"]["key"],
    config["cookie"]["expiry_days"]
)

# Render login widget
auth.login(location='main', key='Login')

# Controlla stato autenticazione
if not st.session_state.get('authentication_status'):
    st.warning("ðŸ”’ Inserisci username e password")
    st.stop()

# Utente autenticato
env_name = st.session_state.get('name')
env_username = st.session_state.get('username')

# Pulsante di logout nella sidebar
auth.logout("Logout", "sidebar")

st.title("Dashboard Binance Bot")



# --- Configurazione API Testnet ----------------
API_KEY    = os.getenv('BINANCE_API_KEY')
API_SECRET = os.getenv('BINANCE_API_SECRET')
client     = Client(API_KEY, API_SECRET, testnet=True)

# --- Configurazione DB e Log ----------------
DB_PATH  = 'trades.db'
LOG_PATH = Path('logs') / 'scheduler.log'

# Mapping timeframe -> (Binance interval, ms)
INTERVAL_MAP = {
    'M5':    ('5m',    5 * 60 * 1000),
    'H1':    ('1h',    1 * 3600 * 1000),
    'H4':    ('4h',    4 * 3600 * 1000),
    'Daily': ('1d',   24 * 3600 * 1000),
}

from symbols import SYMBOLS

# --- Sidebar: Saldo Testnet USDC ----------------
st.sidebar.subheader('Saldo Testnet USDC')
balances = client.get_account().get('balances', [])
usdc_bal    = next((b for b in balances if b['asset']=='USDC'), {'free':'0','locked':'0'})
free_usdc   = float(usdc_bal['free'])
locked_usdc = float(usdc_bal['locked'])
st.sidebar.metric('Disponibile', f"{free_usdc:.2f} USDC", f"Locked: {locked_usdc:.2f}")

# â€” Prefetch di tutti i ticker (una sola API call)
tickers   = client.get_all_tickers()
price_map = {t['symbol']: float(t['price']) for t in tickers}

# â€” Costruisci la lista di asset con valore â‰¥ 10 USDC
other = []
for b in balances:
    asset = b['asset']
    free  = float(b['free'])
    if free <= 0 or asset == 'USDC':
        continue

    symbol = f"{asset}USDC"
    price  = price_map.get(symbol)
    if price is None:
        continue

    value_usdc = free * price
    if value_usdc >= 10:
        other.append((asset, free, price, value_usdc))

# â€” DEBUG: verifico quanti balances e cosa ha messo in `other`
st.sidebar.write(f"ðŸ›  DEBUG: total balances = {len(balances)}")
st.sidebar.write(f"ðŸ›  DEBUG: other list = {other}")

# â€” Expander che si apre solo al click
if other:
    st.sidebar.write("ðŸ›  DEBUG: entro nellâ€™if other")
    with st.sidebar.expander('Altri saldi > $10'):
        for asset, free, price, value in other:
            st.write(f"â€¢ **{asset}**: {free:.4f} @ {price:.4f} â†’ ~${value:.2f}")
n

# â€” Expander che si apre solo al click
if other:
    with st.sidebar.expander('Altri saldi > $10'):  # si apre al click
        for asset, free, price, value in other:
            st.write(f"â€¢ **{asset}**: {free:.4f} @ {price:.4f} â†’ ~${value:.2f}")

# â€”â€”â€” Mostra in expander su click
if other:
    with st.sidebar.expander('Altri saldi > $10'):
        for asset, free, price, val in other:
            st.write(f"â€¢ **{asset}**: {free:.4f} @{price:.4f} â†’ ~${val:.2f}")

# --- Sidebar: Nuovo Trade ----------------
with st.sidebar.form('trade_form'):
    st.header('Nuovo Trade')
    symbols_filtered = [s for s in SYMBOLS if s.endswith('USDC')]
    symbol = st.selectbox('Simbolo', symbols_filtered)
    quantity = st.number_input('QuantitÃ ', min_value=0.0, format='%.4f')
    entry_price = st.number_input('Entry Price', min_value=0.0, format='%.2f')
    entry_interval = st.selectbox('Entry Interval', list(INTERVAL_MAP.keys()))
    take_profit = st.number_input('Take Profit', min_value=0.0, format='%.2f')
    stop_loss = st.number_input('Stop Loss', min_value=0.0, format='%.2f')
    stop_interval = st.selectbox('Stop Interval', list(INTERVAL_MAP.keys()))
    if st.form_submit_button('Aggiungi Trade'):
        if not (stop_loss < entry_price < take_profit):
            st.error('Stop Loss < Entry Price < Take Profit richiesto.')
        else:
            last_close = float(fetch_last_closed_candle(symbol, entry_interval)[4])
            if last_close >= take_profit:
                st.error(f'Candela precedente {entry_interval} ({last_close:.2f}) â‰¥ TP; non inserito.')
            else:
                # Calcola il timestamp ISO UTC
                ts = datetime.datetime.now(datetime.timezone.utc).isoformat()
                # 2) Verifica saldo prima di inserire in DB
                quote_asset = symbol[-4:]
                required = float(entry_price) * float(quantity)
                account      = client.get_account()
                balances     = {b['asset']: float(b['free']) for b in account.get('balances', [])}
                available    = balances.get(quote_asset, 0.0)

                if available < required:
                    msg = (
                        f"âŒ Saldo insufficiente: richiesti {required:.2f} {quote_asset}, "
                        f"disponibili {available:.2f} {quote_asset}."
                    )
                    st.error(msg)
                else:
                    # Inserisci il trade in stato PENDING
                    conn = sqlite3.connect(DB_PATH)
                    conn.execute(
                        "INSERT INTO orders("
                        "symbol, quantity, entry_price, take_profit, stop_loss, "
                        "entry_interval, stop_interval, status, created_at"
                        ") VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
                        (
                            symbol,
                            quantity,
                            entry_price,
                            take_profit,
                            stop_loss,
                            entry_interval,
                            stop_interval,
                            'PENDING',
                            ts
                        )
                    )
                    conn.commit()
                    st.success("âœ… Trade aggiunto come PENDING")
                    conn.close()
                    st.success('Trade aggiunto!')
                try:
                    st.experimental_rerun()
                except AttributeError:
                    st.write('â†» Ricarica pagina per aggiornamenti')

# --- Caricamento dati dal DB ----------------
conn     = sqlite3.connect(DB_PATH)
pending  = pd.read_sql("SELECT * FROM orders WHERE status='PENDING'", conn)
executed = pd.read_sql("SELECT * FROM orders WHERE status='EXECUTED'", conn)
closed   = pd.read_sql("SELECT * FROM orders WHERE status LIKE 'CLOSED_%'", conn)
conn.close()

# Layout a due colonne
col1, col2 = st.columns(2)

# --- Colonna 1: Ordini Pendenti --------
with col1:
    st.subheader('Ordini Pendenti')
    if pending.empty:
        st.write('Nessun ordine pendente.')
    else:
        df = pending.copy()
        # Tipi numerici
        df[['quantity','entry_price','take_profit','stop_loss']] = df[['quantity','entry_price','take_profit','stop_loss']].astype(float)
        # Last Close
        df['last_close'] = df.apply(lambda o: float(fetch_last_closed_candle(o['symbol'], o['entry_interval'])[4]), axis=1)
        # Stato
        df['stato'] = df.apply(lambda o: 'Pronto' if o['last_close']>=o['entry_price'] else 'In Attesa', axis=1)
        # Valore in USDT
        df['value_usd'] = df['quantity'] * df['entry_price']
        # Selezione e rinomina colonne
        disp = df[['id','symbol','quantity','entry_price','value_usd','take_profit','stop_loss','last_close','stato']]
        disp = disp.rename(columns={
            'id':'ID','symbol':'Simbolo','quantity':'Qty','entry_price':'Entry Price',
            'value_usd':'Valore (USDT)','take_profit':'TP','stop_loss':'SL',
            'last_close':'Last Close','stato':'Stato'
        })
        # Nascondi indice e mostra
        disp = disp.reset_index(drop=True)
        st.dataframe(disp, use_container_width=True, hide_index=True)
        # Annulla Pending
        sel = st.selectbox('Annulla ID (Pending)', disp['ID'], key='cancel_pending')
        if st.button('Annulla Segnale Pending', key='btn_cancel_pending'):
            conn = sqlite3.connect(DB_PATH)
            conn.execute("UPDATE orders SET status='CLOSED_MANUAL' WHERE id=?", (int(sel),))
            conn.commit(); conn.close()
            try:
                st.experimental_rerun()
            except AttributeError:
                st.write('â†» Ricarica pagina per aggiornamenti')

# --- Colonna 2: Ordini a Mercato -------
with col2:
    st.subheader('Ordini a mercato')
    if executed.empty:
        st.write('Nessun ordine a mercato.')
    else:
        df = executed.copy()
        # Tipi numerici
        df[['quantity','entry_price','executed_price']] = df[['quantity','entry_price','executed_price']].astype(float)
        # Formatta data di esecuzione
        df['executed_at'] = pd.to_datetime(df['executed_at']).dt.strftime('%d/%m/%Y %H:%M:%S')
        # Valore in USDT
        df['value_usd'] = df['quantity'] * df['executed_price']
        # Selezione e rinomina
        disp = df[['id','symbol','quantity','entry_price','value_usd','entry_interval','executed_price','executed_at','take_profit','stop_loss','stop_interval','status']]
        disp = disp.rename(columns={
            'id':'ID','symbol':'Simbolo','quantity':'Qty','entry_price':'Entry Price',
            'value_usd':'Valore (USDT)','entry_interval':'Interval','executed_price':'Exec Price',
            'executed_at':'Exec Time','take_profit':'TP','stop_loss':'SL','stop_interval':'SL Interval','status':'Status'
        })
        # Nascondi indice e mostra
        disp = disp.reset_index(drop=True)
        st.dataframe(disp, use_container_width=True, hide_index=True)

        # Annulla Eseguiti
        sel2 = st.selectbox('Annulla ID (Eseguiti)', disp['ID'], key='cancel_exec')
        if st.button('Annulla Segnale Eseguito', key='btn_cancel_exec'):
            row = disp[disp['ID'] == sel2].iloc[0]
            try:
                balances = client.get_account().get('balances', [])
                asset = row['Simbolo'][:-4]  # es. BTC da BTCUSDC
                available_qty = next((b for b in balances if b['asset'] == asset), {'free': '0'})['free']
                available_qty = float(available_qty)

                qty_order = float(row['Qty'])
                qty_to_sell = min(available_qty, qty_order)

                if qty_to_sell <= 0:
                    st.warning(f"âŒ QuantitÃ  non disponibile per vendere {asset}")
                else:
                    qty_str = ('{:.8f}'.format(qty_to_sell)).rstrip('0').rstrip('.')
                    client.create_order(
                        symbol=row['Simbolo'],
                        side='SELL',
                        type='MARKET',
                        quantity=qty_str
                    )
                    conn = sqlite3.connect(DB_PATH)
                    conn.execute("UPDATE orders SET status='CLOSED_MANUAL' WHERE id=?", (int(sel2),))
                    conn.commit()
                    conn.close()
                    st.success(f"âœ… Vendita manuale eseguita: {qty_str} {asset}")
                    st.experimental_rerun()
            except BinanceAPIException as e:
                st.error(f'Errore Binance API: {e}')
            except Exception as e:
                st.error(f'Errore generico: {e}')

# --- Sezione Trade Chiusi -------------
st.markdown('---')
st.subheader('Trade Chiusi')
if closed.empty:
    st.write('Nessun trade chiuso.')
else:
    df = closed.copy()
    # Formatta data di esecuzione
    df['executed_at'] = pd.to_datetime(df['executed_at']).dt.strftime('%d/%m/%Y %H:%M:%S')
    disp = df.rename(columns={
        'id':'ID','symbol':'Simbolo','quantity':'Qty','entry_price':'Entry Price',
        'entry_interval':'Interval','executed_price':'Exec Price','executed_at':'Exec Time',
        'take_profit':'TP','stop_loss':'SL','stop_interval':'SL Interval','status':'Status'
    }).reset_index(drop=True)
    st.dataframe(disp, use_container_width=True, hide_index=True)

# --- Verifica Ultime Candele ---------
st.markdown('---')
st.subheader('Verifica Ultime Candele')
vsym = st.selectbox('Simbolo', symbols_filtered)
candles = []
for nm, (tf_str, _) in INTERVAL_MAP.items():
    ohlc = ccxt.binance().fetch_ohlcv(vsym, timeframe=tf_str, limit=2)[-2]
    candles.append({
        'Interval': nm,
        'Open':  f"{ohlc[1]:.2f}",
        'High':  f"{ohlc[2]:.2f}",
        'Low':   f"{ohlc[3]:.2f}",
        'Close': f"{ohlc[4]:.2f}"
    })
df_candles = pd.DataFrame(candles).reset_index(drop=True)
st.table(df_candles)

# --- Log (ultime 100 righe) ----------
st.markdown('---')
st.subheader('Log (ultime 100)')

if Path(LOG_PATH).exists():
    lines = Path(LOG_PATH).read_text().splitlines()[-100:]
    text = "\n".join(lines)
else:
    text = [f"Log file non trovato: {LOG_PATH}"]

st.text_area('Ultimi log scheduler', lines, height=400)

